// SPDX-License-Identifier: MIT
 pragma solidity ^0.8.4;
 import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract tokentransfer{
    address owner;
    uint256 balance;
event sent(address from, address to,uint amount);
event transferrecieved(address from ,uint amount);
constructor(){
    owner = msg.sender;
}
receive() payable external {
    balance += msg.value;
    emit transferrecieved(msg.sender,msg.value);
}
function withdraw(uint amount, address payable to) public {
require(msg.sender==owner);
require(amount<= balance);

to.transfer(amount);
balance -= amount;
emit sent(msg.sender, to, amount);
}
function TRANSFERERC20(IERC20 token) public {
    
}
}





// SPDX-License-Identifier: MIT
 pragma solidity ^0.8.4;

contract tracker{
uint storagedata;
function set(uint x) public {

storagedata = x;
}
function get() public  view returns (uint){
return storagedata;
}

}  
//sımplest solidity coin contract
contract coin{
address public minter;
mapping (address => uint) public balances;
event sent(address from, address to,uint amount);

constructor(){
    minter = msg.sender;
}
 
function mint(address receiver, uint amount) public { //sadece deploy eden tarafından çağırılabılır
require(minter==msg.sender);   //creat edilen tokenı gönderir
balances[receiver] += amount;
}

error insufficientBalance(uint requested,uint avaliable);


function send(address receiver , uint amount) public {  //send existing coins
    if(amount > balances[msg.sender])
    revert insufficientBalance({requested: amount,avaliable: balances[msg.sender]});

balances[msg.sender] -= amount;
balances[receiver]   += amount;
emit sent(msg.sender, receiver, amount);

}
 //coin görmek için bir blockchain expolerer kurulması gerekıyor   

}








